* Introduction

Py4CL is a bridge between Common Lisp and Python, which enables Common
Lisp to call Python code. It uses streams to communicate with a
separate python process, the approach taken by [[https://github.com/marcoheisig/cl4py][cl4py]]. This is
different to the CFFI approach used by libraries such as [[https://github.com/pinterface/burgled-batteries][burgled-batteries]].

* Examples

The python subprocess can be started and stopped with =python-start= and =python-stop=.
=python-eval= evaluates an expression, converting the result to a suitable lisp type.

#+BEGIN_SRC lisp
(asdf:load-system "py4cl")

(py4cl:python-eval "[i**2 for i in range(5)]") ; => #(0 1 4 9 16)
#+END_SRC

#+RESULTS:
| 0 | 1 | 4 | 9 | 16 |

The python process can be explicitly started and stopped using
=python-start= and =python-stop=, but =py4cl= functions start python
automatically if needed by calling =python-start-if-not-alive=.

** Calling python functions

=python-call= can be used to pass arguments to any python callable, 
such as a function in a module:

#+BEGIN_SRC lisp
(py4cl:python-exec "import math")
(py4cl:python-call "math.sqrt" 42)
#+END_SRC

#+RESULTS:
: 6.4807405

or a lambda function:
#+BEGIN_SRC lisp
(py4cl:python-call "lambda x: 2*x" 21)
#+END_SRC

#+RESULTS:
: 42

Keywords are translated, with the symbol made lowercase:
#+BEGIN_SRC lisp
(py4cl:python-call "lambda a=0, b=1: a-b" :b 2 :a 1)
#+END_SRC

#+RESULTS:
: -1

** Asynchronous python functions

One of the advantages of using streams to communicate with a separate
python process, is that the python and lisp processes can run at the
same time. =python-call-async= calls python but returns a closure
immediately. The python process continues running, and the result can
be retrieved by calling the returned closure. 

#+BEGIN_SRC lisp
(defparameter thunk (py4cl:python-call-async "lambda x: 2*x" 21))

(funcall thunk)  ; => 42
#+END_SRC

#+RESULTS:
: 42

If the function call requires callbacks to lisp, then these will only
be serviced when a =py4cl= function is called. In that case the python
function may not be able to finish until the thunk is called. This
should not result in deadlocks, because all =py4cl= functions can
service callbacks while waiting for a result.

** Importing functions

Python functions can be made available in Lisp by using =import-function=. By
default this makes a function which can take any number of arguments, and then
translates these into a call to the python function.
#+BEGIN_SRC lisp
(asdf:load-system "py4cl")

(py4cl:python-exec "import math")
(py4cl:import-function "math.sqrt")
(math.sqrt 42) ; => 6.4807405
#+END_SRC

#+RESULTS:
: 6.4807405

If a different symbol is needed in Lisp then the =as= keyword can be
used with either a string or symbol:
#+BEGIN_SRC lisp
(py4cl:import-function "sum" :as "pysum")
(pysum '(1 2 3))  ; => 6
#+END_SRC

#+RESULTS:
: 6

This is implemented as a macro which defines a function which in turn calls =python-call=.

** Importing modules

Python modules can be imported as lisp packages using =import-module=.
For example, to import the [[https://matplotlib.org/][matplotlib]] plotting library, and make its functions
available in the package =PLT= from within Lisp:
#+BEGIN_SRC lisp :session import-example
(asdf:load-system "py4cl")
(py4cl:import-module "matplotlib.pyplot" :as "plt") ; Creates PLT package
#+END_SRC

#+RESULTS:
: T

This will also import it into the python process as the module =plt=, so that
=python-call= or =python-eval= can also make use of the =plt= module. 

Like =python-exec=, =python-call= and other similar functions, 
=import-module= starts python if it is not already running, so that
the available functions can be discovered.

The python docstrings are made available as Lisp function docstrings, so we can see them
using =describe=:
#+BEGIN_SRC  lisp :session import-example
(describe 'plt:plot)
#+END_SRC

Functions in the =PLT= package can be used to make simple plots:
#+BEGIN_SRC lisp :session import-example
(plt:plot #(1 2 3 2 1) :color "r")
(plt:show)
#+END_SRC

#+RESULTS:
: NIL

* Exporting a function to python

Lisp functions can be passed as arguments to =python-call= 
or imported functions:
#+BEGIN_SRC lisp
(py4cl:python-exec "from scipy.integrate import romberg")

(py4cl:python-call "romberg" 
                   (lambda (x) (/ (exp (- (* x x)))
                                  (sqrt pi)))
                   0.0 1.0) ; Range of integration
#+END_SRC

#+RESULTS:
: 0.4213504

Lisp functions can be made available to python code using =export-function=:
#+BEGIN_SRC lisp
(py4cl:python-exec "from scipy.integrate import romberg")

(py4cl:export-function (lambda (x) (/ (exp (- (* x x)))
                                      (sqrt pi))) "gaussian")

(py4cl:python-eval "romberg(gaussian, 0.0, 1.0)") ; => 0.4213504
#+END_SRC

#+RESULTS:
: 0.4213504

* Internal details
** Messages formats

Messages consist of a single character, followed by a number (N) in string
format e.g. "12", a newline, then N characters. 

*** Lisp to Python

The first character of the message describes the type of message:
- `x` means run `exec`, and is used for statements where no return
  value is expected e.g. `import` statements
- `e` means run `eval`, to evaluate an expression and return the
  result

*** Python to Lisp

The first character can be:
- `r` indicates a return value
- `e` indicates an error, followed by a message
- `c` indicates a callback, calling a lisp function and expecting a
  value to be sent back to python

Strings sent to Lisp are processed with `read-from-string` to obtain a
value. 
